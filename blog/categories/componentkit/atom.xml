<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ComponentKit | I'm DavidYang]]></title>
  <link href="http://www.davidyanggo.me/blog/categories/componentkit/atom.xml" rel="self"/>
  <link href="http://www.davidyanggo.me/"/>
  <updated>2015-05-05T00:48:52+08:00</updated>
  <id>http://www.davidyanggo.me/</id>
  <author>
    <name><![CDATA[David Yang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ComponentKit 最佳实践，注意细节]]></title>
    <link href="http://www.davidyanggo.me/blog/2015/04/02/componentkit-zui-jia-shi-jian-%2Czhu-yi-xi-jie/"/>
    <updated>2015-04-02T21:54:23+08:00</updated>
    <id>http://www.davidyanggo.me/blog/2015/04/02/componentkit-zui-jia-shi-jian-,zhu-yi-xi-jie</id>
    <content type="html"><![CDATA[<p>ComponentKit  最佳实践,开发中需要注意的地方</p>

<!--more-->


<p>1:代码行不超过300行：</p>

<p>  代码行多维护起来就不方便，组件化的代码文件快总共最好不要超过300行，如果超过，最佳的处理方式是拆分单独的CKCompositeComponent</p>

<p>2：避免直接设置组件宽度100%，不利于组件重用。好的处理方式是通过父组件来制定宽度
   比如如果父组件是CKStackLayoutComponent,使用CKStackLayoutAlignItemsStretch 拉伸填充</p>

<p>3: 通过+new创建一个组件，nil检查
   +new 创建的对象，又可以为空，比如：</p>

<p>``` c++</p>

<p>   @implementation MyComponent</p>

<pre><code> {
        NSString *_name;
 }

 + (instancetype)newWithName:(NSString *)name
 {
        MyComponent *c = [super newWithComponent:...];
        c-&gt;_name = [name copy]; // Crashes if c is nil
        return c;
 }
</code></pre>

<p>```</p>

<pre><code> 正确的做法是检查对象c是否为空
</code></pre>

<p>4：代码块避免过多的分支，分支过多，可读性不好
   比如</p>

<p>``` c++</p>

<ul>
<li><p> (instancetype)newWithArticle:(Article <em>)article
 {
      CKComponent </em>headerComponent;
      if (article.featured) {
        headerComponent = [FeaturedArticleHeaderComponent newWithArticle:article];
      } else {
        headerComponent = [RegularArticleHeaderComponent newWithArticle:article];
      }</p>

<pre><code>  UIEdgeInsets insets = {10, 10, 10, 10};
  CGFloat imageSize = 20;
  if (iPad) {
    insets = {20, 20, 20, 20};
    imageSize = 40;
  }

  return [super newWithComponent:
          [CKStackLayoutComponent
           newWithView:{}
           size:{}
           style:{}
           children:{
             {headerComponent},
             {[ArticleTextComponent
               newWithArticle:article
               insets:insets
               imageSize:imageSize]},
           }]]
</code></pre>

<p>}</p></li>
</ul>


<p>```</p>

<pre><code>如果分支过多，考虑把组件拆分到单独的小组件，再利用复合模式组装起立
</code></pre>

<p>5： Components 不能够被delegate引用</p>

<pre><code>Components 的生命周期都是短暂的，不是手动控制。 可选的是采用CKComponentController，CKComponentController生命持久的，他们持久化跟踪每个版本comonent 的更新。

比如下面的方式是不推荐的
</code></pre>

<p>``` c++</p>

<pre><code>@implementation AlertDisplayComponent &lt;UIAlertViewDelegate&gt;
{
  UIAlertView *_alertView;
}

- (void)didTapDisplayAlert
{
  _alertView = [[UIAlertView alloc] initWithTitle:@"Are you sure?"
                                          message:nil
                                         delegate:self ...];
  [_alertView show];
}

- (void)alertView:(UIAlertView *)alert didDismissWithButtonIndex:(NSInteger)buttonIndex
{
  [self updateState:...];
}
@end
</code></pre>

<p>```</p>

<p>  因为上面的组件self 可能deallocate，所以alert的delegate为空，不是你想要的结果
   最佳方式</p>

<p>``` c++</p>

<p>   @interface AlertDisplayComponentController : CKComponentController <UIAlertViewDelegate></p>

<p>   @end</p>

<pre><code>@implementation AlertDisplayComponentController
{
  UIAlertView *_alertView;
}

- (void)didTapDisplayAlert

  _alertView = [[UIAlertView alloc] initWithTitle:@"Are you sure?"
                                          message:nil
                                         delegate:self ...];
  [_alertView show];
}

- (void)alertView:(UIAlertView *)alert didDismissWithButtonIndex:(NSInteger)buttonIndex
{
  [self.component updateState:...];
}
@end
</code></pre>

<p>```</p>

<p>6： 对象传递到组件应该不可变的</p>

<pre><code>因为+new 在后台线程创建，创建的组件在多线程操作，可变的对象mutable 是nonatomic,即便是atomic，还是存在race condition,会影响代码的逻辑
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ComponentKit 优势与劣势]]></title>
    <link href="http://www.davidyanggo.me/blog/2015/04/02/componentkit-you-shi-yu-lie-shi/"/>
    <updated>2015-04-02T21:49:41+08:00</updated>
    <id>http://www.davidyanggo.me/blog/2015/04/02/componentkit-you-shi-yu-lie-shi</id>
    <content type="html"><![CDATA[<p>ComponentKit 突出的地方是在复杂的列表视图，在Facebook的News Feed IOS版本app得到了很好的体现</p>

<!--more-->


<p>优势：</p>

<p>  1：简单声明式：就像React 这个javascript库一样。</p>

<p>  2：滑动性能的提升：所有的布局操作都在后台线程操作，这样主线程不会太忙</p>

<p>  3；View回收重用，所有组件视图都是按照声明表达式方式来配置，使得view可以很好的自动回收重用</p>

<p>  4: 组件化：组件使得Compnentkit构建负责的UI，不会超过300行代码</p>

<p>注意点：</p>

<p>  1：UI接口不是list或者表格不适合ComponentKit</p>

<p>  2: ComponentKit 要求C++，Objective。 目前还没有Swift版本</p>
]]></content>
  </entry>
  
</feed>
