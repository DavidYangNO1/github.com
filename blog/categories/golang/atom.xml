<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | I'm DavidYang]]></title>
  <link href="http://www.davidyanggo.me/blog/categories/golang/atom.xml" rel="self"/>
  <link href="http://www.davidyanggo.me/"/>
  <updated>2017-02-12T22:28:46+08:00</updated>
  <id>http://www.davidyanggo.me/</id>
  <author>
    <name><![CDATA[David Yang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[阿里百川IM golang API接口]]></title>
    <link href="http://www.davidyanggo.me/blog/2016/11/08/openim/"/>
    <updated>2016-11-08T16:33:00+08:00</updated>
    <id>http://www.davidyanggo.me/blog/2016/11/08/openim</id>
    <content type="html"><![CDATA[<p>阿里百川IM golang API接口</p>

<!--more-->


<p>项目需要接阿里百川的IM，看官方文档没有golang版本的SDK，好吧只能够自己对着后台用golang 写对应的IM API，目前已经完成了添加好友，删除好友，更新好友。 在开发过程中发现阿里百川的返回格式只能够说太不严谨了，解析响应消息格式，希望他们能够好好完善吧，阿弥陀佛。</p>

<h1>封装的接口目录机构</h1>


<p>fl_const.go 主要是接口地址，appkey,appsecret的定义，根据参数获取阿里百川的沙盒。测试中发现阿里百川居然还没有实现沙箱环境，所以大家都用生产环境去测试吧。</p>

<p>fl_post.go  主要是一个通用的网络接口，参照百川的文档对参数排序，md5加密,调用百川的接口</p>

<p>fl_im.go  主要就是已经实现的3个业务接口，添加，更新，删除好友接口，至于百川的其它接口 可以仿照添加对应的接口调用</p>

<h1>好友添加Demo</h1>


<p>``` c++
1：配置</p>

<pre><code>func configIM() {
    freeAliim.AppKey = freeFile.FlAppInfo.IMAppkey
    freeAliim.AppSecret = freeFile.FlAppInfo.IMAppSecret
    freeAliim.IsPro = freeFile.FlAppInfo.IsPro
    freeAliim.UseHTTP = freeFile.FlAppInfo.UseHTTP
}
</code></pre>

<p>2：传参数</p>

<pre><code>imUserinfo := freeAliim.ImUserInfo{
    Userid:   userid,
    Password: pwd,
    Name:     name,
    IconUrl:  iconUrl,
}
</code></pre>

<p>3： 调用封装的接口</p>

<pre><code>succ, resposne := freeAliim.SendAddUsers(imUserinfos)
if succ == false {

} else {

}
</code></pre>

<p>```</p>

<h1>总结</h1>


<p>选择小众语言就会遇上使用第三方SDK，没有对应的实现SDK，什么都要自己写，爱折腾
快乐编码，活着玩命，不是玩命活着，爱好徒步，目前创业中</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[golang + Protobuffs]]></title>
    <link href="http://www.davidyanggo.me/blog/2016/05/25/goprotobuf/"/>
    <updated>2016-05-25T00:28:00+08:00</updated>
    <id>http://www.davidyanggo.me/blog/2016/05/25/goprotobuf</id>
    <content type="html"><![CDATA[<p>许多APP在通讯交互格式这块，通常会选择JSON,或者 plain text, JSON应为Node.js 开发的上升尤其受欢迎。真实情况，JSON并不是很快的一种格式，所以protobuf 做为一种可选项，具体更快，更容易使用，速度比起JSON快多了。</p>

<!--more-->


<p>基于JSON与Protobu性能比较如下</p>

<p><img src="/images/benchmark.png"></p>

<p>下面就一步步讲解下golang 环境下这么使用protobuf</p>

<p>1)环境搭建
   1.1:mac 环境安装 protoc
<code>c++
   brew install protoc  (brew mac 神器，你懂得)
</code>
   1.2:安装protobuf 插件
<code>c++
   go get -u github.com/golang/protobuf/protoc-gen-go
</code></p>

<p>2）通讯协议文件 .proto &ndash;> NetMessage.proto
``` c++
// version
syntax = &ldquo;proto3&rdquo;;
// package of the file
package main;</p>

<p>message Client{</p>

<pre><code>required int32 id = 1;
optional string name = 2;
optional string email = 3;
optional string country = 4;

message Mail {
    optional string remoteEmail  =1;
    optional string body = 2; 
}

repeated Mail inbox = 5;
</code></pre>

<p>}
```
   以上定义了客户端与服务端通讯的消息格式</p>

<p>3）导出协议对应的go文件
``` c++</p>

<pre><code>protoc --go_out=. NetMessage.proto
</code></pre>

<p>```</p>

<p>4) 创建服务端</p>

<p>   服务端主要是在POST消息体里面接收一个protobu。然后打印出打的内容，具体代码如下
``` c++
package main</p>

<p>import (</p>

<pre><code>"fmt"
"github.com/golang/protobuf/proto"
"io/ioutil"
"net/http"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    myClient := Client{}
    data, err := ioutil.ReadAll(r.Body)
    if err != nil {
        fmt.Println(err)
    }

    if err := proto.Unmarshal(data, &amp;myClient); err != nil {
        fmt.Println(err)
    }

    println(myClient.Id, ":", myClient.Name, ":", myClient.Email, ":", myClient.Country)

    for _, mail := range myClient.Inbox {
        fmt.Println(mail.RemoteEmail, ":", mail.Body)
    }
})
http.ListenAndServe(":3000", nil)
</code></pre>

<p>}</p>

<p>```</p>

<p>5) 创建客户端
   客户端主要创建代码生成的client 结构体，把它的内容发送到服务器，代码如下：
``` c++
package main</p>

<p>import (</p>

<pre><code>"bytes"
"fmt"
"github.com/golang/protobuf/proto"
"net/http"
</code></pre>

<p>)</p>

<p>func main() {</p>

<pre><code>myClient := Client{Id: 1, Name: "David Yang", Email: "davidyanggo@gmail.com", Country: "CH"}
clientInbox := make([]*Client_Mail, 0, 20)
clientInbox = append(clientInbox,
    &amp;Client_Mail{RemoteEmail: "davidyanggo1@gmail.com", Body: "Hello. davidyanggo1."},
    &amp;Client_Mail{RemoteEmail: "davidyanggo2@gmail.com", Body: "Bye, davidyanggo2."}
)
myClient.Inbox = clientInbox

data, err := proto.Marshal(&amp;myClient)
if err != nil {
    fmt.Println(err)
    return
}

_, err = http.Post("http://localhost:3000", "", bytes.NewBuffer(data))

if err != nil {
    fmt.Println(err)
    return
}
</code></pre>

<p>}</p>

<p>```</p>

<p>总结：
protobuf 很容易使用，提高应用程序的交互速度，推荐在项目里面使用。
想要更深入了解参考一下文档：<a href="https://developers.google.com/protocol-buffers/docs/gotutorial">https://developers.google.com/protocol-buffers/docs/gotutorial</a></p>

<p>快乐编码，活着玩命，不是玩命活着</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios 结合 golang gomobile 产生这样的火花]]></title>
    <link href="http://www.davidyanggo.me/blog/2016/03/25/gomobile-ios/"/>
    <updated>2016-03-25T02:55:00+08:00</updated>
    <id>http://www.davidyanggo.me/blog/2016/03/25/gomobile-ios</id>
    <content type="html"><![CDATA[<p>golang 开发基础服务组件，write once, run everwhere(主要是iOS，Android)</p>

<!--more-->


<p>gomobile 工具让你编译go 代码，在iOS 里面调用，使用gomobile,可以把golang 写的基础组件，在Android,iOS,服务端直接共享，通讯。
下面的教程主要讲下从配置环境的iOS里面调用go package代码.</p>

<h1>安装gomobile</h1>


<p>首先：下载安装gomobile
<code>c++
1:go get golang.org/x/mobile/cmd/gomobile
2:gomobile init
</code>
第1步主要是下载安装，第二步会配置安装编译器，主要是用来打包成ios，Android,底层是C++编译器，生成打包的。主要是下载下面两个包：gomobile-ndk-r10e-linux-x86_64，gomobile-ndk-r10e-darwin-x86_64。需要翻墙。</p>

<h1>用go写一个基础组件，golang里面叫做Package</h1>


<p>``` c++
package example</p>

<p>func Add(x int, y int) int {</p>

<pre><code>return x + y
</code></pre>

<p>}
```
使用下面命令编译上面的go代码，生成Framework.
gomobile bind -target ios package文件夹。</p>

<p>上面会生成一个以go package命名的iOS framework</p>

<h1>iOS 调用 framework</h1>


<p>把上面生成的framework 拖到xcode 工程里面去,
打包生成的go代码到OC这边都是C函数，以go+package+go函数名称 命名的，
OC就可以直接调用了。</p>

<h1>gomobile的遐想</h1>


<p>gomobile 解决了前后端write run everwhere.简单说移动端的基础组件，服务，可以用golang 来写，android,iOS都可以调用。 做基础组件开发不错选择。至于是否可以用golang 来开个进程，给iOS弄个后天服务，不知道可行么，后续可以尝试下。拥抱未来吧</p>
]]></content>
  </entry>
  
</feed>
